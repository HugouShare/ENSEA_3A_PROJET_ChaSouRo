(- faire les statistiques)
- corriger le code de reconnaissance de clusters
(- faire le code d'interpolarisation)
- faire le code de dÃ©tection des ennemis


























#include "LIDAR.h"

extern TIM_HandleTypeDef LID_htimx;
extern UART_HandleTypeDef LID_huartx;

uint8_t lid_rx_buf[LID_RX_BUF_SIZE];
static LIDAR_Frame current_frame = {0};
LIDAR_Sample LID_list_of_samples[LID_SAMPLE_NUMBER];

uint16_t sample_cnt = 0; //debug


////////////////////////////////////////////////////////////////////////FUNCTIONS

void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == LID_huartx.Instance)
    {
        // Process first half of buffer
        LID_ProcessDMA(lid_rx_buf, LID_RX_BUF_SIZE / 2, false);
    }
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == LID_huartx.Instance)
    {
        // Process second half of buffer
        LID_ProcessDMA(&lid_rx_buf[LID_RX_BUF_SIZE / 2], LID_RX_BUF_SIZE / 2, true);
    }
}


void LIDAR_Init(void)
{
    HAL_TIM_PWM_Start(&LID_htimx, LID_TIM_CHANNEL_X);
    HAL_UART_Receive_DMA(&LID_huartx, lid_rx_buf, LID_RX_BUF_SIZE);
    LID_TIMX_SetDuty(35);
}

void LID_TIMX_SetDuty(uint8_t duty_percent) {
    if (duty_percent > 100) duty_percent = 100;
    uint32_t arr = __HAL_TIM_GET_AUTORELOAD(&LID_htimx);
    uint32_t ccr = (duty_percent * (arr + 1)) / 100;
    __HAL_TIM_SET_COMPARE(&LID_htimx, LID_TIM_CHANNEL_X, ccr);
}


bool verify_checksum(const uint8_t *buf, uint16_t len)
{
    if (len % 2 != 0) {
        // Longueur invalide : pas un multiple de 2
        return false;
    }

    uint16_t acc = 0;

    for (uint16_t i = 0; i < len; i += 2)
    {
        uint16_t w = (uint16_t)buf[i];
        w |= (uint16_t)buf[i + 1] << 8;
        acc ^= w;
    }

    return (acc == 0);
}

void LID_ProcessDMA(uint8_t *data, uint16_t len, bool RxCpltCallback)
{
    static uint16_t buff_idx = 0;
    static bool frame_detected = false;
    static uint16_t expected_len = 0;
    static uint8_t sample_count = 0;

    for(uint16_t i = 0; i < len; i++){
        uint8_t b = data[i];

        // -----------------------------
        // Detect header 0xAA55
        // -----------------------------
        if(buff_idx == 0 && b == 0xAA) { current_frame.data[0] = b; buff_idx = 1; continue; }
        if(buff_idx == 1 && b == 0x55) { current_frame.data[1] = b; buff_idx = 2; continue; }

        // -----------------------------
        // Read CT
        // -----------------------------
        if(buff_idx == 2) { current_frame.data[2] = b; buff_idx++; continue; }

        // -----------------------------
        // Read LSN (sample count)
        // -----------------------------
        if(buff_idx == 3){
            current_frame.data[3] = b;
            buff_idx++;
            sample_count = current_frame.data[3];

            // sanity check
            if(sample_count > ((MAX_FRAME_SIZE - 10)/2)){ buff_idx = 0; frame_detected = false; continue; }

            expected_len = 10 + 2*sample_count;
            frame_detected = true;
            continue;
        }

        // -----------------------------
        // Accumulate remaining bytes
        // -----------------------------
        if(frame_detected && buff_idx < expected_len){
            current_frame.data[buff_idx++] = b;
            continue;
        }

        // -----------------------------
        // Full frame received
        // -----------------------------
        if(frame_detected && buff_idx == expected_len){
            if(!verify_checksum(current_frame.data, expected_len)){ buff_idx = 0; frame_detected = false; continue; }

            uint16_t FSA = (uint16_t)current_frame.data[4] | ((uint16_t)current_frame.data[5]<<8);
            uint16_t LSA = (uint16_t)current_frame.data[6] | ((uint16_t)current_frame.data[7]<<8);

            float angle_fsa = (float)(FSA>>1)/64.0f;
            float angle_lsa = (float)(LSA>>1)/64.0f;
            float diff_angle = angle_lsa - angle_fsa; if(diff_angle<0) diff_angle += 360.0f;

            for(uint16_t s = 0; s < sample_count; s++){
                uint16_t offset = 10 + 2*s;
                uint16_t S_i = (uint16_t)current_frame.data[offset] | ((uint16_t)current_frame.data[offset+1]<<8);

                float distance_mm_f = (float)(S_i>>2);
                float angle_deg_f = (sample_count==1)? angle_fsa : angle_fsa + (diff_angle*s)/(sample_count-1);

                if(distance_mm_f > 0.0f){
                    float ratio = 21.8f*(155.3f - distance_mm_f)/(155.3f*distance_mm_f);
                    angle_deg_f += atanf(ratio)*RAD_TO_DEG;
                }

                if(angle_deg_f >= 360.0f) angle_deg_f -= 360.0f;
                if(angle_deg_f < 0.0f) angle_deg_f += 360.0f;

                LIDAR_Sample sample;
                sample.distance_mm = (uint16_t)distance_mm_f;
                sample.angle_deg_x10 = (uint16_t)(angle_deg_f*10);
                sample.quality = (S_i & 0x0001)? 0:1;
                sample.start_of_scan = false;

                LID_Store_Sample(sample);
            }

            // Reset for next frame
            buff_idx = 0;
            frame_detected = false;
        }
    }
}







void LID_Store_Sample(LIDAR_Sample sample){
    uint16_t idx = sample.angle_deg_x10;
    if(idx >= LID_SAMPLE_NUMBER) return;

    if(LID_list_of_samples[idx].quality != 0x1)
        sample_cnt++;

    LID_list_of_samples[idx].distance_mm    = sample.distance_mm;
    LID_list_of_samples[idx].angle_deg_x10  = sample.angle_deg_x10;
    LID_list_of_samples[idx].quality        = sample.quality;
    LID_list_of_samples[idx].start_of_scan  = sample.start_of_scan;
}


void LIDAR_Reset_Scan(void){
	//jsp
}
